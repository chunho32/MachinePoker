// Generated by CoffeeScript 1.12.5
(function() {
  var EventEmitter, Game, MachinePoker, Player, async, binions, botNameCollision,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  async = require('async');

  binions = require('binions');

  Player = binions.Player;

  Game = binions.Game;

  exports.seats = {
    JsLocal: require('./seats/js_local'),
    Remote: require('./seats/remote'),
    SocketSeat: require('./seats/socketSeat')
  };

  exports.betting = binions.betting;

  exports.observers = {
    fileLogger: require('./observers/file_logger'),
    logger: require('./observers/logger'),
    narrator: require('./observers/narrator')
  };

  exports.create = function(betting) {
    return new MachinePoker(betting);
  };

  MachinePoker = (function(superClass) {
    extend(MachinePoker, superClass);

    function MachinePoker(opts) {
      this.opts = opts;
      if (this.opts == null) {
        this.opts = {};
      }
      this.chips = this.opts.chips || 1000;
      this.maxRounds = this.opts.maxRounds || 100;
      this.betting = this.opts.betting || binions.betting.noLimit(10, 20);
      this.observers = [];
      this.players = [];
      this.currentRound = 1;
      this.waitingNewRoundTime = 2000;
    }

    MachinePoker.prototype.addObserver = function(obs) {
      var event, i, len, ref, results;
      this.observers.push(obs);
      ref = ['roundStart', 'stateChange', 'complete', 'tournamentComplete', 'betAction', 'playerBetStart'];
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        event = ref[i];
        if (obs[event]) {
          results.push(this.on(event, obs[event].bind(obs)));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    MachinePoker.prototype.removeObserver = function(obs) {
      this.removeAllListeners();
      return this.observers = null;
    };

    MachinePoker.prototype.addPlayers = function(bots) {
      var bot, i, len, name, names, results;
      this.players = [];
      names = [];
      results = [];
      for (i = 0, len = bots.length; i < len; i++) {
        bot = bots[i];
        name = botNameCollision(names, bot.name);
        names.push(name);
        results.push(this.addPlayer(new Player(bot, bot.player.info.chips, name)));
      }
      return results;
    };

    MachinePoker.prototype.addPlayer = function(player) {
      player.on('betAction', (function(_this) {
        return function(action, amount, err) {
          return _this.emit('betAction', player, action, amount, err);
        };
      })(this));
      return this.players.push(player);
    };

    MachinePoker.prototype.run = function() {
      var game;
      if (this.players.length > 1) {
        game = new Game(this.players, this.betting, this.currentRound);
        game.on('roundStart', (function(_this) {
          return function() {
            return _this.emit('roundStart', game.status(Game.STATUS.PRIVILEGED));
          };
        })(this));
        game.on('stateChange', (function(_this) {
          return function(state) {
            return _this.emit('stateChange', game.status(Game.STATUS.PRIVILEGED));
          };
        })(this));
        game.on('playerBetStart', (function(_this) {
          return function(player) {
            return _this.emit('playerBetStart', player);
          };
        })(this));
        game.once('complete', (function(_this) {
          return function(status) {
            var numPlayer;
            _this.emit('complete', game.status(Game.STATUS.PRIVILEGED));
            _this.currentRound++;
            numPlayer = (_this.players.filter(function(p) {
              return p.chips > 0;
            })).length;
            if (_this.currentRound > _this.maxRounds || numPlayer < 2) {
              _this.emit('tournamentComplete', _this.players);
              return _this._close();
            } else {
              return setTimeout(function() {
                return _this.run();
              }, _this.waitingNewRoundTime);
            }
          };
        })(this));
        return game.run();
      } else if (this.players.length > 0) {

      } else {
        return this._close();
      }
    };

    MachinePoker.prototype.start = function() {
      this.players.sort(function() {
        return Math.random() > 0.5;
      });
      return this.run();
    };

    MachinePoker.prototype.stop = function() {};

    MachinePoker.prototype._close = function(callback) {
      var i, len, obs, ref, waitingOn;
      waitingOn = 0;
      if (this.observers === null) {
        return;
      }
      ref = this.observers;
      for (i = 0, len = ref.length; i < len; i++) {
        obs = ref[i];
        if (obs['onObserverComplete']) {
          waitingOn++;
          obs.onObserverComplete(function() {
            waitingOn--;
            if (waitingOn <= 0) {
              return typeof callback === "function" ? callback() : void 0;
            }
          });
        }
      }
      if (waitingOn <= 0) {
        this.emit('tournamentClosed');
        return typeof callback === "function" ? callback() : void 0;
      }
    };

    return MachinePoker;

  })(EventEmitter);

  botNameCollision = function(existing, name, idx) {
    var altName;
    altName = name;
    idx || (idx = 1);
    if (idx > 1) {
      altName = name + " #" + idx;
    }
    if (existing.indexOf(altName) >= 0) {
      return botNameCollision(existing, name, idx + 1);
    }
    return altName;
  };

}).call(this);
